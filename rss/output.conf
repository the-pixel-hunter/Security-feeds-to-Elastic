#Output config for all RSS feeds, also hashes the title to use as ID so duplicates arent created

filter{
	mutate{
		rename => { "Feed" => "rss.feed.url" }
		rename => { "author" => "rss.article.author" }
		rename => { "link" => "rss.article.url" }
		rename => { "message" => "rss.article.message" }
		rename => { "title" => "rss.article.title" }
		rename => { "published" => "rss.article.published" }
		rename => { "author" => "rss.article.updated" }
		copy => {"rss.article.title" => "rss.article.words"}
	}
	mutate{
		gsub => [ "rss.article.words", "[,!:&]", ""
		"rss.article.words", "0day|zero-day|0-day|zeroday|zero day", "0-Day"]
		split => { "rss.article.words" => "\s" }
		if "CVE" in [rss.article.title]
		{
		 	add_tag => "CVE"
		}
		if "cve" in [rss.article.title]
		{
		 	add_tag => "CVE"
		}
	}

	# Calculate the age of the article from the current date
	ruby{
		code => "event.set('rss.article.age', Time.now.to_f - event.get('@timestamp').to_f"
	}
	# 7 represents the number of days to allow.
	if [rss.article.age] > (60 * 60 * 24 * 7) {
		drop{}
	}
	# Generatets a fingerprint which is used as the document ID to prevent duplicates forming within elastic 
	fingerprint{
		source => ["rss.article.url"]
		target => "[@metadata][fingerprint]"
		method => "MURMUR3"
	}
}

output{
	elasticsearch{
		index => "rss-feeds-%{+YYYY.MM.dd}"
		document_id => "%{[@metadata][fingerprint]}"
		pipeline => "rss-feed-ingest"
	}
}
